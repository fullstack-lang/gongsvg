// generated by ModelGongFileTemplate
package models

import "sort"

// swagger:ignore
type __void struct{}

// needed for creating set of instances in the stage
var __member __void

// StageStruct enables storage of staged instances
// swagger:ignore
type StageStruct struct { // insertion point for definition of arrays registering instances
	Rects map[*Rect]struct{}

	SVGs map[*SVG]struct{}

	Texts map[*Text]struct{}

	AllModelsStructCreateCallback AllModelsStructCreateInterface

	AllModelsStructDeleteCallback AllModelsStructDeleteInterface

	BackRepo BackRepoInterface
}

type BackRepoInterface interface {
	Commit(stage *StageStruct)
	Checkout(stage *StageStruct)
	// insertion point for Commit and Checkout signatures
	CommitRect(rect *Rect)
	CheckoutRect(rect *Rect)
	CommitSVG(svg *SVG)
	CheckoutSVG(svg *SVG)
	CommitText(text *Text)
	CheckoutText(text *Text)
	GetLastCommitNb() uint
}

// swagger:ignore instructs the gong compiler (gongc) to avoid this particular struct
var Stage StageStruct = StageStruct{ // insertion point for array initiatialisation
	Rects: make(map[*Rect]struct{}, 0),

	SVGs: make(map[*SVG]struct{}, 0),

	Texts: make(map[*Text]struct{}, 0),

}

func (stage *StageStruct) Commit() {
	if stage.BackRepo != nil {
		stage.BackRepo.Commit(stage)
	}
}

func (stage *StageStruct) Checkout() {
	if stage.BackRepo != nil {
		stage.BackRepo.Checkout(stage)
	}
}

// insertion point for cumulative sub template with model space calls
func (stage *StageStruct) getRectOrderedStructWithNameField() []*Rect {
	// have alphabetical order generation
	rectOrdered := []*Rect{}
	for rect := range stage.Rects {
		rectOrdered = append(rectOrdered, rect)
	}
	sort.Slice(rectOrdered[:], func(i, j int) bool {
		return rectOrdered[i].Name < rectOrdered[j].Name
	})
	return rectOrdered
}

// Stage puts rect to the model stage
func (rect *Rect) Stage() *Rect {
	Stage.Rects[rect] = __member
	return rect
}

// Unstage removes rect off the model stage
func (rect *Rect) Unstage() *Rect {
	delete(Stage.Rects, rect)
	return rect
}

// commit rect to the back repo (if it is already staged)
func (rect *Rect) Commit() *Rect {
	if _, ok := Stage.Rects[rect]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitRect(rect)
		}
	}
	return rect
}

// Checkout rect to the back repo (if it is already staged)
func (rect *Rect) Checkout() *Rect {
	if _, ok := Stage.Rects[rect]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutRect(rect)
		}
	}
	return rect
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of rect to the model stage
func (rect *Rect) StageCopy() *Rect {
	_rect := new(Rect)
	*_rect = *rect
	_rect.Stage()
	return _rect
}

// StageAndCommit appends rect to the model stage and commit to the orm repo
func (rect *Rect) StageAndCommit() *Rect {
	rect.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMRect(rect)
	}
	return rect
}

// DeleteStageAndCommit appends rect to the model stage and commit to the orm repo
func (rect *Rect) DeleteStageAndCommit() *Rect {
	rect.Unstage()
	DeleteORMRect(rect)
	return rect
}

// StageCopyAndCommit appends a copy of rect to the model stage and commit to the orm repo
func (rect *Rect) StageCopyAndCommit() *Rect {
	_rect := new(Rect)
	*_rect = *rect
	_rect.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMRect(rect)
	}
	return _rect
}

// CreateORMRect enables dynamic staging of a Rect instance
func CreateORMRect(rect *Rect) {
	rect.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMRect(rect)
	}
}

// DeleteORMRect enables dynamic staging of a Rect instance
func DeleteORMRect(rect *Rect) {
	rect.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMRect(rect)
	}
}

func (stage *StageStruct) getSVGOrderedStructWithNameField() []*SVG {
	// have alphabetical order generation
	svgOrdered := []*SVG{}
	for svg := range stage.SVGs {
		svgOrdered = append(svgOrdered, svg)
	}
	sort.Slice(svgOrdered[:], func(i, j int) bool {
		return svgOrdered[i].Name < svgOrdered[j].Name
	})
	return svgOrdered
}

// Stage puts svg to the model stage
func (svg *SVG) Stage() *SVG {
	Stage.SVGs[svg] = __member
	return svg
}

// Unstage removes svg off the model stage
func (svg *SVG) Unstage() *SVG {
	delete(Stage.SVGs, svg)
	return svg
}

// commit svg to the back repo (if it is already staged)
func (svg *SVG) Commit() *SVG {
	if _, ok := Stage.SVGs[svg]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitSVG(svg)
		}
	}
	return svg
}

// Checkout svg to the back repo (if it is already staged)
func (svg *SVG) Checkout() *SVG {
	if _, ok := Stage.SVGs[svg]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutSVG(svg)
		}
	}
	return svg
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of svg to the model stage
func (svg *SVG) StageCopy() *SVG {
	_svg := new(SVG)
	*_svg = *svg
	_svg.Stage()
	return _svg
}

// StageAndCommit appends svg to the model stage and commit to the orm repo
func (svg *SVG) StageAndCommit() *SVG {
	svg.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMSVG(svg)
	}
	return svg
}

// DeleteStageAndCommit appends svg to the model stage and commit to the orm repo
func (svg *SVG) DeleteStageAndCommit() *SVG {
	svg.Unstage()
	DeleteORMSVG(svg)
	return svg
}

// StageCopyAndCommit appends a copy of svg to the model stage and commit to the orm repo
func (svg *SVG) StageCopyAndCommit() *SVG {
	_svg := new(SVG)
	*_svg = *svg
	_svg.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMSVG(svg)
	}
	return _svg
}

// CreateORMSVG enables dynamic staging of a SVG instance
func CreateORMSVG(svg *SVG) {
	svg.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMSVG(svg)
	}
}

// DeleteORMSVG enables dynamic staging of a SVG instance
func DeleteORMSVG(svg *SVG) {
	svg.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMSVG(svg)
	}
}

func (stage *StageStruct) getTextOrderedStructWithNameField() []*Text {
	// have alphabetical order generation
	textOrdered := []*Text{}
	for text := range stage.Texts {
		textOrdered = append(textOrdered, text)
	}
	sort.Slice(textOrdered[:], func(i, j int) bool {
		return textOrdered[i].Name < textOrdered[j].Name
	})
	return textOrdered
}

// Stage puts text to the model stage
func (text *Text) Stage() *Text {
	Stage.Texts[text] = __member
	return text
}

// Unstage removes text off the model stage
func (text *Text) Unstage() *Text {
	delete(Stage.Texts, text)
	return text
}

// commit text to the back repo (if it is already staged)
func (text *Text) Commit() *Text {
	if _, ok := Stage.Texts[text]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitText(text)
		}
	}
	return text
}

// Checkout text to the back repo (if it is already staged)
func (text *Text) Checkout() *Text {
	if _, ok := Stage.Texts[text]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutText(text)
		}
	}
	return text
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of text to the model stage
func (text *Text) StageCopy() *Text {
	_text := new(Text)
	*_text = *text
	_text.Stage()
	return _text
}

// StageAndCommit appends text to the model stage and commit to the orm repo
func (text *Text) StageAndCommit() *Text {
	text.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMText(text)
	}
	return text
}

// DeleteStageAndCommit appends text to the model stage and commit to the orm repo
func (text *Text) DeleteStageAndCommit() *Text {
	text.Unstage()
	DeleteORMText(text)
	return text
}

// StageCopyAndCommit appends a copy of text to the model stage and commit to the orm repo
func (text *Text) StageCopyAndCommit() *Text {
	_text := new(Text)
	*_text = *text
	_text.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMText(text)
	}
	return _text
}

// CreateORMText enables dynamic staging of a Text instance
func CreateORMText(text *Text) {
	text.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMText(text)
	}
}

// DeleteORMText enables dynamic staging of a Text instance
func DeleteORMText(text *Text) {
	text.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMText(text)
	}
}

// swagger:ignore
type AllModelsStructCreateInterface interface { // insertion point for Callbacks on creation
	CreateORMRect(Rect *Rect)
	CreateORMSVG(SVG *SVG)
	CreateORMText(Text *Text)
}

type AllModelsStructDeleteInterface interface { // insertion point for Callbacks on deletion
	DeleteORMRect(Rect *Rect)
	DeleteORMSVG(SVG *SVG)
	DeleteORMText(Text *Text)
}

func (stage *StageStruct) Reset() { // insertion point for array reset
	stage.Rects = make(map[*Rect]struct{}, 0)
	stage.SVGs = make(map[*SVG]struct{}, 0)
	stage.Texts = make(map[*Text]struct{}, 0)
}

func (stage *StageStruct) Nil() { // insertion point for array nil
	stage.Rects = nil
	stage.SVGs = nil
	stage.Texts = nil
}
