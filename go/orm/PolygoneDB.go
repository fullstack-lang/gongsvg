// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/jinzhu/gorm"
	"github.com/fullstack-lang/gongsvg/go/models"
)

// dummy variable to have the import database/sql wihthout compile failure id no sql is used
var dummy_Polygone sql.NullBool
var __Polygone_time__dummyDeclaration time.Duration

// PolygoneAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model polygoneAPI
type PolygoneAPI struct {
	models.Polygone

	// insertion for fields declaration
	// Declation for basic field polygoneDB.Name {{BasicKind}} (to be completed)
	Name_Data sql.NullString

	// Declation for basic field polygoneDB.Points {{BasicKind}} (to be completed)
	Points_Data sql.NullString

	// Declation for basic field polygoneDB.Color {{BasicKind}} (to be completed)
	Color_Data sql.NullString

	// Declation for basic field polygoneDB.FillOpacity {{BasicKind}} (to be completed)
	FillOpacity_Data sql.NullFloat64

	// Declation for basic field polygoneDB.Stroke {{BasicKind}} (to be completed)
	Stroke_Data sql.NullString

	// Declation for basic field polygoneDB.StrokeWidth {{BasicKind}} (to be completed)
	StrokeWidth_Data sql.NullFloat64

	// Declation for basic field polygoneDB.StrokeDashArray {{BasicKind}} (to be completed)
	StrokeDashArray_Data sql.NullString

	// Implementation of a reverse ID for field SVG{}.Polygones []*Polygone
	SVG_PolygonesDBID sql.NullInt64

	// end of insertion
}

// PolygoneDB describes a polygone in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model polygoneDB
type PolygoneDB struct {
	gorm.Model

	PolygoneAPI
}

// PolygoneDBs arrays polygoneDBs
// swagger:response polygoneDBsResponse
type PolygoneDBs []PolygoneDB

// PolygoneDBResponse provides response
// swagger:response polygoneDBResponse
type PolygoneDBResponse struct {
	PolygoneDB
}

type BackRepoPolygoneStruct struct {
	// stores PolygoneDB according to their gorm ID
	Map_PolygoneDBID_PolygoneDB *map[uint]*PolygoneDB

	// stores PolygoneDB ID according to Polygone address
	Map_PolygonePtr_PolygoneDBID *map[*models.Polygone]uint

	// stores Polygone according to their gorm ID
	Map_PolygoneDBID_PolygonePtr *map[uint]*models.Polygone

	db *gorm.DB
}

// BackRepoPolygone.Init set up the BackRepo of the Polygone
func (backRepoPolygone *BackRepoPolygoneStruct) Init(db *gorm.DB) (Error error) {

	if backRepoPolygone.Map_PolygoneDBID_PolygonePtr != nil {
		err := errors.New("In Init, backRepoPolygone.Map_PolygoneDBID_PolygonePtr should be nil")
		return err
	}

	if backRepoPolygone.Map_PolygoneDBID_PolygoneDB != nil {
		err := errors.New("In Init, backRepoPolygone.Map_PolygoneDBID_PolygoneDB should be nil")
		return err
	}

	if backRepoPolygone.Map_PolygonePtr_PolygoneDBID != nil {
		err := errors.New("In Init, backRepoPolygone.Map_PolygonePtr_PolygoneDBID should be nil")
		return err
	}

	tmp := make(map[uint]*models.Polygone, 0)
	backRepoPolygone.Map_PolygoneDBID_PolygonePtr = &tmp

	tmpDB := make(map[uint]*PolygoneDB, 0)
	backRepoPolygone.Map_PolygoneDBID_PolygoneDB = &tmpDB

	tmpID := make(map[*models.Polygone]uint, 0)
	backRepoPolygone.Map_PolygonePtr_PolygoneDBID = &tmpID

	backRepoPolygone.db = db
	return
}

// BackRepoPolygone.CommitPhaseOne commits all staged instances of Polygone to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoPolygone *BackRepoPolygoneStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for polygone := range stage.Polygones {
		backRepoPolygone.CommitPhaseOneInstance(polygone)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, polygone := range *backRepoPolygone.Map_PolygoneDBID_PolygonePtr {
		if _, ok := stage.Polygones[polygone]; !ok {
			backRepoPolygone.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoPolygone.CommitDeleteInstance commits deletion of Polygone to the BackRepo
func (backRepoPolygone *BackRepoPolygoneStruct) CommitDeleteInstance(id uint) (Error error) {

	polygone := (*backRepoPolygone.Map_PolygoneDBID_PolygonePtr)[id]

	// polygone is not staged anymore, remove polygoneDB
	polygoneDB := (*backRepoPolygone.Map_PolygoneDBID_PolygoneDB)[id]
	query := backRepoPolygone.db.Unscoped().Delete(&polygoneDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	delete((*backRepoPolygone.Map_PolygonePtr_PolygoneDBID), polygone)
	delete((*backRepoPolygone.Map_PolygoneDBID_PolygonePtr), id)
	delete((*backRepoPolygone.Map_PolygoneDBID_PolygoneDB), id)

	return
}

// BackRepoPolygone.CommitPhaseOneInstance commits polygone staged instances of Polygone to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoPolygone *BackRepoPolygoneStruct) CommitPhaseOneInstance(polygone *models.Polygone) (Error error) {

	// check if the polygone is not commited yet
	if _, ok := (*backRepoPolygone.Map_PolygonePtr_PolygoneDBID)[polygone]; ok {
		return
	}

	// initiate polygone
	var polygoneDB PolygoneDB
	polygoneDB.Polygone = *polygone

	query := backRepoPolygone.db.Create(&polygoneDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*backRepoPolygone.Map_PolygonePtr_PolygoneDBID)[polygone] = polygoneDB.ID
	(*backRepoPolygone.Map_PolygoneDBID_PolygonePtr)[polygoneDB.ID] = polygone
	(*backRepoPolygone.Map_PolygoneDBID_PolygoneDB)[polygoneDB.ID] = &polygoneDB

	return
}

// BackRepoPolygone.CommitPhaseTwo commits all staged instances of Polygone to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoPolygone *BackRepoPolygoneStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, polygone := range *backRepoPolygone.Map_PolygoneDBID_PolygonePtr {
		backRepoPolygone.CommitPhaseTwoInstance(backRepo, idx, polygone)
	}

	return
}

// BackRepoPolygone.CommitPhaseTwoInstance commits {{structname }} of models.Polygone to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoPolygone *BackRepoPolygoneStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, polygone *models.Polygone) (Error error) {

	// fetch matching polygoneDB
	if polygoneDB, ok := (*backRepoPolygone.Map_PolygoneDBID_PolygoneDB)[idx]; ok {

		{
			{
				// insertion point for fields commit
				polygoneDB.Name_Data.String = polygone.Name
				polygoneDB.Name_Data.Valid = true

				polygoneDB.Points_Data.String = polygone.Points
				polygoneDB.Points_Data.Valid = true

				polygoneDB.Color_Data.String = polygone.Color
				polygoneDB.Color_Data.Valid = true

				polygoneDB.FillOpacity_Data.Float64 = polygone.FillOpacity
				polygoneDB.FillOpacity_Data.Valid = true

				polygoneDB.Stroke_Data.String = polygone.Stroke
				polygoneDB.Stroke_Data.Valid = true

				polygoneDB.StrokeWidth_Data.Float64 = polygone.StrokeWidth
				polygoneDB.StrokeWidth_Data.Valid = true

				polygoneDB.StrokeDashArray_Data.String = polygone.StrokeDashArray
				polygoneDB.StrokeDashArray_Data.Valid = true

			}
		}
		query := backRepoPolygone.db.Save(&polygoneDB)
		if query.Error != nil {
			return query.Error
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Polygone intance %s", polygone.Name))
		return err
	}

	return
}

// BackRepoPolygone.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One is the creation of instance in the stage
//
// NOTE: the is supposed to have been reset before
//
func (backRepoPolygone *BackRepoPolygoneStruct) CheckoutPhaseOne() (Error error) {

	polygoneDBArray := make([]PolygoneDB, 0)
	query := backRepoPolygone.db.Find(&polygoneDBArray)
	if query.Error != nil {
		return query.Error
	}

	// copy orm objects to the the map
	for _, polygoneDB := range polygoneDBArray {
		backRepoPolygone.CheckoutPhaseOneInstance(&polygoneDB)
	}

	return
}

// CheckoutPhaseOneInstance takes a polygoneDB that has been found in the DB, updates the backRepo and stages the
// models version of the polygoneDB
func (backRepoPolygone *BackRepoPolygoneStruct) CheckoutPhaseOneInstance(polygoneDB *PolygoneDB) (Error error) {

	// if absent, create entries in the backRepoPolygone maps.
	polygoneWithNewFieldValues := polygoneDB.Polygone
	if _, ok := (*backRepoPolygone.Map_PolygoneDBID_PolygonePtr)[polygoneDB.ID]; !ok {

		(*backRepoPolygone.Map_PolygoneDBID_PolygonePtr)[polygoneDB.ID] = &polygoneWithNewFieldValues
		(*backRepoPolygone.Map_PolygonePtr_PolygoneDBID)[&polygoneWithNewFieldValues] = polygoneDB.ID

		// append model store with the new element
		polygoneWithNewFieldValues.Stage()
	}
	polygoneDBWithNewFieldValues := *polygoneDB
	(*backRepoPolygone.Map_PolygoneDBID_PolygoneDB)[polygoneDB.ID] = &polygoneDBWithNewFieldValues

	return
}

// BackRepoPolygone.CheckoutPhaseTwo Checkouts all staged instances of Polygone to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoPolygone *BackRepoPolygoneStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, polygoneDB := range *backRepoPolygone.Map_PolygoneDBID_PolygoneDB {
		backRepoPolygone.CheckoutPhaseTwoInstance(backRepo, polygoneDB)
	}
	return
}

// BackRepoPolygone.CheckoutPhaseTwoInstance Checkouts staged instances of Polygone to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoPolygone *BackRepoPolygoneStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, polygoneDB *PolygoneDB) (Error error) {

	polygone := (*backRepoPolygone.Map_PolygoneDBID_PolygonePtr)[polygoneDB.ID]
	_ = polygone // sometimes, there is no code generated. This lines voids the "unused variable" compilation error
	{
		{
			// insertion point for checkout, i.e. update of fields of stage instance from fields of back repo instances
			//
			polygone.Name = polygoneDB.Name_Data.String

			polygone.Points = polygoneDB.Points_Data.String

			polygone.Color = polygoneDB.Color_Data.String

			polygone.FillOpacity = polygoneDB.FillOpacity_Data.Float64

			polygone.Stroke = polygoneDB.Stroke_Data.String

			polygone.StrokeWidth = polygoneDB.StrokeWidth_Data.Float64

			polygone.StrokeDashArray = polygoneDB.StrokeDashArray_Data.String

		}
	}
	return
}

// CommitPolygone allows commit of a single polygone (if already staged)
func (backRepo *BackRepoStruct) CommitPolygone(polygone *models.Polygone) {
	backRepo.BackRepoPolygone.CommitPhaseOneInstance(polygone)
	if id, ok := (*backRepo.BackRepoPolygone.Map_PolygonePtr_PolygoneDBID)[polygone]; ok {
		backRepo.BackRepoPolygone.CommitPhaseTwoInstance(backRepo, id, polygone)
	}
}

// CommitPolygone allows checkout of a single polygone (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutPolygone(polygone *models.Polygone) {
	// check if the polygone is staged
	if _, ok := (*backRepo.BackRepoPolygone.Map_PolygonePtr_PolygoneDBID)[polygone]; ok {

		if id, ok := (*backRepo.BackRepoPolygone.Map_PolygonePtr_PolygoneDBID)[polygone]; ok {
			var polygoneDB PolygoneDB
			polygoneDB.ID = id

			if err := backRepo.BackRepoPolygone.db.First(&polygoneDB, id).Error; err != nil {
				log.Panicln("CheckoutPolygone : Problem with getting object with id:", id)
			}
			backRepo.BackRepoPolygone.CheckoutPhaseOneInstance(&polygoneDB)
			backRepo.BackRepoPolygone.CheckoutPhaseTwoInstance(backRepo, &polygoneDB)
		}
	}
}
